use sqlx::SqlitePool;
use crate::database::models::{Setting, TranscriptSetting};


#[derive(serde::Deserialize, Debug)]
pub struct SaveModelConfigRequest {
    pub provider: String,
    pub model: String,
    #[serde(rename = "whisperModel")]
    pub whisper_model: String,
    #[serde(rename = "apiKey")]
    pub api_key: Option<String>,
}

#[derive(serde::Deserialize, Debug)]
pub struct SaveTranscriptConfigRequest {
    pub provider: String,
    pub model: String,
    #[serde(rename = "apiKey")]
    pub api_key: Option<String>,
}

pub struct SettingsRepository;

// Transcript providers: localWhisper, deepgram, elevenLabs, groq, openai
// Summary providers: openai, claude, ollama, groq, added openrouter
// NOTE: Handle data exclusion in the higher layer as this is database abstraction layer(using SELECT *)

impl SettingsRepository {
    pub async fn get_model_config(pool: &SqlitePool) -> std::result::Result<Option<Setting>, sqlx::Error> {
        let setting = sqlx::query_as::<_, Setting>("SELECT * FROM settings LIMIT 1")
            .fetch_optional(pool)
            .await?;
        Ok(setting)
    }

    pub async fn save_model_config(pool: &SqlitePool, provider: &str, model: &str, whisper_model: &str) -> std::result::Result<(), sqlx::Error> {
        // Using id '1' for backward compatibility
        sqlx::query(
            r#"
            INSERT INTO settings (id, provider, model, whisperModel)
            VALUES ('1', $1, $2, $3)
            ON CONFLICT(id) DO UPDATE SET
                provider = excluded.provider,
                model = excluded.model,
                whisperModel = excluded.whisperModel
            "#
        )
        .bind(provider)
        .bind(model)
        .bind(whisper_model)
        .execute(pool)
        .await?;

        Ok(())
    }

    pub async fn save_api_key(pool: &SqlitePool, provider: &str, api_key: &str) -> std::result::Result<(), sqlx::Error> {
        let api_key_column = match provider {
            "openai" => "openaiApiKey",
            "claude" => "anthropicApiKey",
            "ollama" => "ollamaApiKey",
            "groq" => "groqApiKey",
            "openrouter" => "openRouterApiKey",
            _ => return Err(sqlx::Error::Protocol(format!("Invalid provider: {}", provider).into())),
        };

        let query = format!(
            r#"
            INSERT INTO settings (id, provider, model, whisperModel, "{}")
            VALUES ('1', 'openai', 'gpt-4o-2024-11-20', 'large-v3', $1)
            ON CONFLICT(id) DO UPDATE SET
                "{}" = $1
            "#,
            api_key_column, api_key_column
        );
        sqlx::query(&query)
            .bind(api_key)
            .execute(pool)
            .await?;

        Ok(())
    }

    pub async fn get_api_key(pool: &SqlitePool, provider: &str) -> std::result::Result<Option<String>, sqlx::Error> {
        let api_key_column = match provider {
            "openai" => "openaiApiKey",
            "ollama" => "ollamaApiKey",
            "groq" => "groqApiKey",
            "claude" => "anthropicApiKey",
            "openrouter" => "openRouterApiKey",
            _ => return Err(sqlx::Error::Protocol(format!("Invalid provider: {}", provider).into())),
        };

        let query = format!("SELECT {} FROM settings WHERE id = '1' LIMIT 1", api_key_column);
        let api_key = sqlx::query_scalar(&query)
            .fetch_optional(pool)
            .await?;
        Ok(api_key)
    }

    pub async fn get_transcript_config(pool: &SqlitePool) -> std::result::Result<Option<TranscriptSetting>, sqlx::Error> {
        let setting = sqlx::query_as::<_, TranscriptSetting>("SELECT * FROM transcript_settings LIMIT 1")
            .fetch_optional(pool)
            .await?;
        Ok(setting)

        // TODO: In higher layer if provider is not found(not returned anything from  here),
        // return default values localWhisper and large-v3
    }

    pub async fn save_transcript_config(pool: &SqlitePool, provider: &str, model: &str) -> std::result::Result<(), sqlx::Error> {
        sqlx::query(
            r#"
            INSERT INTO transcript_settings (id, provider, model)
            VALUES ('1', $1, $2)
            ON CONFLICT(id) DO UPDATE SET
                provider = excluded.provider,
                model = excluded.model
            "#
        )
        .bind(provider)
        .bind(model)
        .execute(pool)
        .await?;

        Ok(())
    }

    pub async fn save_transcript_api_key(pool: &SqlitePool, provider: &str, api_key: &str) -> std::result::Result<(), sqlx::Error> {
        let api_key_column = match provider {
            "localWhisper" => "whisperApiKey",
            "deepgram" => "deepgramApiKey",
            "elevenLabs" => "elevenLabsApiKey",
            "groq" => "groqApiKey",
            "openai" => "openaiApiKey",
            _ => return Err(sqlx::Error::Protocol(format!("Invalid provider: {}", provider).into())),
        };

        let query = format!(
            r#"
            INSERT INTO transcript_settings (id, provider, model, "{}")
            VALUES ('1', 'localWhisper', 'large-v3', $1)
            ON CONFLICT(id) DO UPDATE SET
                "{}" = $1
            "#,
            api_key_column, api_key_column
        );
        sqlx::query(&query)
            .bind(api_key)
            .execute(pool)
            .await?;

        Ok(())
    }

    pub async fn get_transcript_api_key(pool: &SqlitePool, provider: &str) -> std::result::Result<Option<String>, sqlx::Error> {
        let api_key_column = match provider {
            "localWhisper" => "whisperApiKey",
            "deepgram" => "deepgramApiKey",
            "elevenLabs" => "elevenLabsApiKey",
            "groq" => "groqApiKey",
            "openai" => "openaiApiKey",
            _ => return Err(sqlx::Error::Protocol(format!("Invalid provider: {}", provider).into())),
        };

        let query = format!("SELECT {} FROM transcript_settings WHERE id = '1' LIMIT 1", api_key_column);
        let api_key = sqlx::query_scalar(&query)
            .fetch_optional(pool)
            .await?;
        Ok(api_key)
    }

    pub async fn delete_api_key(pool: &SqlitePool, provider: &str) -> std::result::Result<(), sqlx::Error> {
        let api_key_column = match provider {
            "openai" => "openaiApiKey",
            "ollama" => "ollamaApiKey",
            "groq" => "groqApiKey",
            "claude" => "anthropicApiKey",
            "openrouter" => "openRouterApiKey",
            _ => return Err(sqlx::Error::Protocol(format!("Invalid provider: {}", provider).into())),
        };

        let query = format!("UPDATE settings SET {} = NULL WHERE id = '1'", api_key_column);
        sqlx::query(&query)
            .execute(pool)
            .await?;

        Ok(())
    }
}
